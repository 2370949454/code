# JVM

### hotspot对象内存分配

+ 指针碰撞

````
用一个指针作为作为分离点的指示器，每次内存分配就将指针往空闲内存偏移；
前提是Java堆是规整的，空闲内存和占用内存被区分开来；
````

+ 空闲列表

````
需要维护一个列表，记录每块内存可用和占用状态，每次分配内存从列表查找大小合适的空闲区域，再更新列表；
效率比指针碰撞的方式低，但是可以适用于Java堆非规整的场景；
````

+ hotspot如何决定分配方式？

````
由于Java堆是非规整决定，这取决于采用的垃圾收集器是否带有空间压缩整理的能力；
Serial、ParNew具有空间压缩整理的能力，所以使用指针碰撞；
````

+ 并发环境下，hotspot如何保证分配内存的线程安全？

````
1.使用CAS+失败重试的保证原子性；
2.TLAB方式，在每个线程中预留一块缓存区域，每次分配先在缓存区域分配，只有当缓存区内存不足时再同步分配；
是否采用TLAB方式取决于-XX:+/-UseTLAB参数设定
````

### hotspot对象内存布局

#### 对象=对象头+实例数据+对齐填充


+ 对象头组成

|  存储内容   | 标志位  | 状态 |
|  ----  | ----  |  ----  | 
| 对象哈希码、对象分代年龄  | 01 |未锁定 |
| 指向锁记录的指针  | 00 |轻量级锁定 |
| 指向重量级锁的指针  | 10 | 重量级锁定|
| 空，无需记录信息  | 11 |GC标志 |
| 偏向线程ID、偏向时间戳、对象分代年龄  | 01 |可偏向 |


1. gc roots算法实现；
2. 何时触发GC；
3. G1收集器；
4. MinorGC 、Full GC；

